#!/usr/sh
# vim: fdm=marker:fmr=-{,}-:fdl=1:fen
#
# Utilities to use across shell scripts.
#
# More stuff to do here. -{
#
#   - [ ] improve function names
#   - [ ]
#
# }-

# Defaults to 'set -e'.
mm_set() {
  mode="$1"

  if [ "$mode" = "all" ]; then
    set -euxo pipefail
  elif  [ "$mode" = "u" ]; then
    # Exit on undefined variable.
    set -u
  elif  [ "$mode" = "x" ]; then
    # Print all commands before execution.
    set -x
  else
    # Exit on error.
    set -e
  fi
}

mm_now() {
  mode="$1"

  if [ "$mode" = "--path" ]; then
    echo "$(date '+%F_%T' | tr ':' '-')"
  else
    if [ -z "$mode" ]; then
      mode='+%F %T'
    fi
    echo "$(date "$mode")"
  fi
}

# In shell, for return values, 0 is success (eq to true in a conditional) and 1 is failure (eq
# to false in a conditional).
is_debug() {
  # If the variable is empty, we are not in debug mode.
  if [ -z "$MCRA_DEBUG" ]; then
    # Not debug mode.
    return 1
  else
    # Debug mode.
    return 0
  fi
}

debug() {
  if ! is_debug; then
    return 0
  fi

  echo "[$(date '+%F %T')] [debug] $@"
}

alias mm_debug=debug
alias mm_is_debug=is_debug

if is_debug; then
  echo '----------------------------------------------------------------------------'
  echo 'DEBUG MODE ENABLED!'
  echo '----------------------------------------------------------------------------'

  if [ "$MCRA_DEBUG" = "test" ]; then
    debug '$MCRA_DEBUG == test: tests will run'
  fi
fi

error() {
  debug $1

  return 1
}

fatal() {
  echo "$@"

  exit 1
}

has_prefix() {
  if [ $# -ne 2 ]; then
    error 'Usage: has_prefix "original string" "prefix to check".'
  fi

  if [ "${1#$2}" != "$1" ]; then
    # The `${1#$2}` substitution replaces $2 at the beginning of $1, making it different from
    # itself, hence entering this branch and confirming that $2 is a prefix on $1.
    return 0  # true
  else
    return 1  # false
  fi
}

count=1
assert() {
  if ! is_debug; then
    return 0
  fi

  test_name=$1
  expected=$2
  actual=$3

  echo -n "[$(date '+%F %T')] [test] $count "
  if [ "$expected" != "$actual" ]; then
    echo -n "failure: $test_name\n\n"
    echo "expected:\n\n$expected\n"
    echo "actual:\n\n$actual"
  else
    echo -n "success: $test_name"
  fi

  echo

  count=$((count + 1))
}


get_this_file_dir() {
  echo "$(command -v readlink >/dev/null 2>&1 && dirname $(readlink -f "$1") || dirname "$1")"
}

mm_is_command() {
  command -v "$1" >/dev/null 2>&1
}

mm_file_path() {
  path=$1
  if mm_is_command readline; then
    echo "$(readlink -f "$path")"
  elif mm_is_command realpath; then
    echo "$(realpath "$path")"
  else
    fatal "Need 'readlink' or 'realpath' and they were not found."
  fi
}

mm_dir_path() {
  echo "$(dirname $(mm_file_path "$1"))"
}

mm_grep() {
  grep_cmd='grep' # Default.

  echo 'rg egrep' | tr ' ' '\n' | while read cmd; do
    if mm_is_command $cmd; then
      grep_cmd="$cmd"
      break
    fi
  done

  $grep_cmd "$@"
}

# Next commands above.

# /////////////////////////////////////////////////////////////////////////
# Tests.
# /////////////////////////////////////////////////////////////////////////
#
# Functions are tested here, but ignored when debug is disabled.

# Run tests.
if [ "$MCRA_DEBUG" = "test" ]
then
  has_prefix "hello world" "hello" && assert "prefix match" $? 0
  has_prefix "hello world" "world" || assert "prefix doesn't match" $? 1
  has_prefix "hello world" "not there" || assert "prefix doesn't match with completely different strings" $? 1

  assert "get_this_file_dir" $(get_this_file_dir $0) "$HOME/projects/dotfiles"
fi

