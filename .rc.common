#!/usr/bin/env sh
# vim:tw=80:ts=4:sw=4:ai:et:ff=unix:fenc=utf-8:et:fixeol:eol:fdm=marker:fdl=0:fen:
#
# Utilities for all shell scripts.
#
# More stuff to do here. {{{
#
# - [ ] figure out a better way to name functions (shell doesn't have namespaces)
#
# }}}

# Defaults to 'set -e'.
mm_set() {
  mode="$1"

  if [ "$mode" = "all" ]; then
    set -euxo pipefail
  elif  [ "$mode" = "u" ]; then
    # Exit on undefined variable.
    set -u
  elif  [ "$mode" = "x" ]; then
    # Print all commands before execution.
    set -x
  else
    # Exit on error.
    set -e
  fi
}

mm_now() {
    mode="$1"

    if [ "$mode" = "--path" ]; then
        echo "$(date '+%F_%T' | tr ':' '-')"
    elif [ "$mode" = "--simple" ]; then
        echo "$(date '+%d%b%y/%Hh%M')"
    else
        if [ -z "$mode" ]; then
            mode='+%F %T'
        fi
        echo "$(date "$mode")"
    fi
}

# In shell, for return values, 0 is success (eq to true in a conditional) and 1 is failure (eq
# to false in a conditional).
is_debug() {
  # If the variable is empty, we are not in debug mode.
  if [ -z "$MCRA_DEBUG" ]; then
    # Not debug mode.
    return 1
  else
    # Debug mode.
    return 0
  fi
}

debug() {
  if ! is_debug; then
    return 0
  fi

  echo "[$(date '+%F %T')] [debug] $@"
}

alias mm_debug=debug
alias mm_is_debug=is_debug

if is_debug; then
  echo '----------------------------------------------------------------------------'
  echo 'DEBUG MODE ENABLED!'
  echo '----------------------------------------------------------------------------'

  if [ "$MCRA_DEBUG" = "test" ]; then
    debug '$MCRA_DEBUG == test: tests will run'
  fi
fi

error() {
  debug $1

  return 1
}

fatal() {
  echo "$@"

  exit 1
}

has_prefix() {
  if [ $# -ne 2 ]; then
    error 'Usage: has_prefix "original string" "prefix to check".'
  fi

  if [ "${1#$2}" != "$1" ]; then
    # The `${1#$2}` substitution replaces $2 at the beginning of $1, making it different from
    # itself, hence entering this branch and confirming that $2 is a prefix on $1.
    return 0  # true
  else
    return 1  # false
  fi
}

count=1
assert() {
  if ! is_debug; then
    return 0
  fi

  test_name=$1
  expected=$2
  actual=$3

  echo -n "[$(date '+%F %T')] [test] $count "
  if [ "$expected" != "$actual" ]; then
    echo -n "failure: $test_name\n\n"
    echo "expected:\n\n$expected\n"
    echo "actual:\n\n$actual"
  else
    echo -n "success: $test_name"
  fi

  echo

  count=$((count + 1))
}


get_this_file_dir() {
  echo "$(command -v readlink >/dev/null 2>&1 && dirname $(readlink -f "$1") || dirname "$1")"
}

mm_is_command() {
  command -v "$1" >/dev/null 2>&1
}

mm_file_path() {
  path=$1
  if mm_is_command readline; then
    echo "$(readlink -f "$path")"
  elif mm_is_command realpath; then
    echo "$(realpath "$path")"
  else
    fatal "Need 'readlink' or 'realpath' and they were not found."
  fi
}

mm_dir_path() {
  echo "$(dirname $(mm_file_path "$1"))"
}

mm_grep() {
  grep_cmd='grep' # Default.

  echo 'rg egrep' | tr ' ' '\n' | while read cmd; do
    if mm_is_command $cmd; then
      grep_cmd="$cmd"
      break
    fi
  done

  $grep_cmd "$@"
}

mm_logfile() {
  local logfile="$1"

  if [ ! -f $logfile ]; then
    touch $logfile
  fi

  echo "\n\n[$(mm_now)]\n\n" >> $logfile
  echo "$logfile"
}

mm_stdout() {
  mm_logfile "/tmp/mcra.stdout.txt"
}

mm_stderr() {
  mm_logfile "/tmp/mcra.stderr.txt"
}

mm_remove_leading_spaces() {
    local num_spaces="${1:-8}"
    local usage="\nUsage: $0 [num]\n\nRemoves [num] leading spaces (default=8)."

    case "$num_spaces" in
        help|-h|--help)
            echo $usage
            return 1
            ;;
    esac

    local check_number="$(echo "$num_spaces" | sed -E -e 's/[1-9][0-9]*//')"

    if [ ! -z "$check_number" ]; then
        echo $usage
        echo "\nInvalid [num]: $1"
        return 1
    fi

    sed -E -e "s/^\s{0,$num_spaces}//"
}

mm_trim() {
    # Remove leading spaces.
    local output1="$(echo "$1" | mm_remove_leading_spaces "$2")"

    # Remove first newline character.
    local output2="${output1#"\n"}"

    # Remove last newline character and output.
    echo "${output2%"\n"}"
}

mm_docs() {
    local usage="
        USAGE:

            mm_docs \$@ '<docs>'
            mm_docs \$@ \"<docs>\"

        NOTES:

            1) The first argument should be literally that. It is what detects
            whether the user wants more information about the function (by
            detecting '-h', '--help' and 'help').

            2) If you want, you can write the <docs> part using newlines and
            leading spaces, as the function will remove them for you. For
            example:

            mm_docs \$@ '
                Here goes your function documentation. The first newline (above)
                along with up to 8 leading spaces
                <--- here
                will be removed for you, as will the last newline right after
                this line.
                <--- here.
            '

            3) You might want to use variable/process substitution, in which
            case you would use the second variation (with double quotes). You
            can still write it as described in 2 above, just replace the single
            quotes for double. In this case, remember to escape double quotes or
            other stuff that should be displayed literally.

            4) If you want a full example, check the following function in this
            file: mm_example_documented_function. It provides the common use
            case for this function.
    "

    # Either this will be called with one or two arguments.
    #
    # If called with only one, the user is trying to get info about this
    # particular function, so show the help.
    #
    # If called with two, the user is documenting their function. In this case,
    # if later the function is called with the first argument being one of the
    # help ones, print the help.
    case "$1" in
        help|-h|--help)
            if [ -z "$2" ]; then
                mm_trim $usage
                return 1
            fi

            mm_trim "$2"
            return 1
            ;;
    esac
    return 0
}

mm_example_documented_function() {
    mm_docs $@ "
        NAME: $0

        DESCRIPTION:

            Shows some example \"mm_docs\" usage and output.

            Run this with different arguments to see different behaviors.
    " || return 1

    echo 'Print this if first argument above is not "help|-h|--help"'
}

# Next commands above.

# /////////////////////////////////////////////////////////////////////////
# Tests.
# /////////////////////////////////////////////////////////////////////////
#
# Functions are tested here, but ignored when debug is disabled.

# Run tests.
if [ "$MCRA_DEBUG" = "test" ]
then
  has_prefix "hello world" "hello" && assert "prefix match" $? 0
  has_prefix "hello world" "world" || assert "prefix doesn't match" $? 1
  has_prefix "hello world" "not there" || assert "prefix doesn't match with completely different strings" $? 1

  assert "get_this_file_dir" $(get_this_file_dir $0) "$HOME/projects/dotfiles"
fi

