[
  // #region VSCode Neovim.

  {
    "key": "VSCODE NEOVIM CONFIGURATION"
  },

  {
    "key": "alt+v",
    "command": "vscode-neovim.stop",
    "when": "neovim.init"
  },

  {
    "key": "alt+v",
    "command": "vscode-neovim.restart",
    "when": "!neovim.init"
  },

  {
    // Enable default ctrl+w behavior to close current active editor (tab):
    //  - Neovim: in all modes, except Insert
    //  - in non-editor windows, e.g. the Settings UI
    "key": "ctrl+w",
    "command": "workbench.action.closeActiveEditor",
    "when": "neovim.init && (neovim.mode != 'insert' || !editorTextFocus)"
  },

  // {
  //   "key": "ctrl+d",
  //   "command": "runCommands",
  //   "args": {
  //     "commands": [
  //       // "editor.action.addSelectionToNextFindMatch",
  //       {
  //         "command": "type", // Type the Esc key
  //         "args": {
  //           "text": "\u001bi"
  //         }
  //       },
  //       // {
  //       //   "command": "type",
  //       //   "args": {
  //       //     "text": "i"
  //       //   }
  //       // },

  //       // {
  //       //   "command": "vscode-neovim.send",
  //       //   "args": ""
  //       // },
  //       "editor.action.addSelectionToNextFindMatch"
  //     ]
  //   },
  //   "when": "neovim.init && editorTextFocus"
  // },

  {
    // Sends <C-d> to Neovim, trying to make it work like <C-d> works in
    // VSCode by default (whatever is selected in visual mode will initiate
    // a multi-cursor selection).
    // I'm not sure how to make it work consistently, but I ended up
    // preferring not to use it anyway.
    "key": "ctrl+d",
    "command": "vscode-neovim.send",
    "args": "<C-d>",
    "when": "neovim.init && (editorTextFocus && neovim.mode == 'visual')"
  },

  // {
  //   // Better to do this in VSCode, as documented in vscode-neovim repo.
  //   // Keeping this here because it might be useful for something else.
  //   "key": "ctrl+d",
  //   "command": "runCommands",
  //   "args": {
  //     "commands": [
  //       {
  //         "command": "type",
  //         "args": {
  //           "text": "A"
  //         }
  //       },
  //       "editor.action.addSelectionToNextFindMatch"
  //       // {
  //       //   "command": "vscode-neovim.send",
  //       //   "args": "i"
  //       // },
  //       // {
  //       //   "command": "type", // Type the Esc key
  //       //   "args": {
  //       //     "text": "\u001b"
  //       //   }
  //       // }
  //     ]
  //   },
  //   "when": "neovim.init && (editorTextFocus && editorHasSelection && neovim.mode == 'visual')"
  // },

  {
    "key": "ctrl+s",
    "command": "runCommands",
    "args": {
      "commands": ["workbench.action.files.save", "vscode-neovim.escape"]
    },
    "when": "neovim.init && (neovim.mode == 'insert')"
  },

  // {
  //   "key": "ctrl+o",
  //   "command": "workbench.action.navigateBack",
  //   "when": "neovim.init && editorTextFocus"
  // },
  // {
  //   "key": "ctrl+i",
  //   "command": "workbench.action.navigateForward",
  //   "when": "neovim.init && editorTextFocus"
  // },

  {
    "key": "VSCODE NEOVIM END - PANEL SHORTCUT CONFIGURATION START"
  },

  // #endregion VSCode Neovim.

  // #region VSCode Vim.

  // {
  //   "key": "alt+v",
  //   "command": "toggleVim"
  // },
  //
  // {
  //   // VSCodeVim.
  //   // Enable default ctrl+w behavior to close current active editor (tab):
  //   //  - nvim: in all modes, except Insert
  //   //  - in non-editor windows, e.g. the Settings UI
  //   "key": "ctrl+w",
  //   "command": "workbench.action.closeActiveEditor",
  //   "when": "vim.mode != 'Insert' || !editorTextFocus"
  // },
  //
  // {
  //   // VSCodeVim.
  //   "key": "ctrl+s",
  //   "command": "runCommands",
  //   "args": {
  //     "commands": ["workbench.action.files.save", "extension.vim_escape"]
  //   },
  //   "when": "vim.mode == 'Insert'"
  // },

  // #endregion VSCode Vim.

  {
    "key": "alt+shift+r",
    "command": "workbench.action.tasks.runTask"
  },

  {
    "key": "alt+b",
    "command": "workbench.action.toggleSidebarVisibility"
  },

  {
    "key": "alt+x",
    "command": "workbench.view.extensions",
    "when": "!sideBarFocus || activeViewlet != 'workbench.view.extensions'"
  },

  {
    "key": "alt+x",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "sideBarFocus && activeViewlet == 'workbench.view.extensions'"
  },

  {
    "key": "alt+shift+m",
    "command": "editor.action.toggleMinimap"
  },

  {
    "key": "alt+g",
    "command": "workbench.view.scm",
    "when": "!sideBarFocus || activeViewlet != 'workbench.view.scm'"
  },

  {
    "key": "alt+g",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "sideBarFocus && activeViewlet == 'workbench.view.scm'"
  },

  {
    "key": "alt+e",
    "command": "workbench.view.explorer",
    "when": "!sideBarFocus || activeViewlet != 'workbench.view.explorer'"
  },

  {
    "key": "alt+e",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "sideBarFocus && activeViewlet == 'workbench.view.explorer'"
  },

  {
    "key": "alt+o",
    "command": "runCommands",
    "args": {
      "commands": ["outline.focus", "outline.focus"]
    },
    "when": "focusedView != 'outline'"
  },

  {
    "key": "alt+o",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "focusedView == 'outline'"
  },

  {
    "key": "alt+shift+f",
    "command": "workbench.view.search",
    "when": "!sideBarFocus || activeViewlet != 'workbench.view.search'"
  },

  {
    "key": "alt+shift+f",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "sideBarFocus && activeViewlet == 'workbench.view.search'"
  },

  {
    "key": "alt+f",
    "command": "workbench.action.findInFiles",
    "when": "!inSearchEditor"
  },

  {
    "key": "alt+f",
    "command": "search.action.focusQueryEditorWidget",
    "when": "inSearchEditor"
  },

  {
    "key": "alt+a",
    "command": "workbench.action.toggleActivityBarVisibility"
  },

  {
    "key": "alt+i",
    "command": "ionide.projectExplorerInActivity.focus"
  },

  {
    "key": "alt+shift+p",
    "command": "issue.copyGithubPermalink"
  },

  // NOTE: I'm trying to do this through the VSCode settings, also adding
  // "alt+shift+l".
  // {
  //   // Open the previous recently used editor.
  //   "key": "alt+l",
  //   "command": "workbench.action.quickOpenPreviousRecentlyUsedEditor",
  //   "when": "!terminalFocus"
  // },

  {
    "key": "alt+k",
    "command": "workbench.action.nextEditor",
    "when": "!panelFocus"
  },

  {
    "key": "alt+j",
    "command": "workbench.action.previousEditor",
    "when": "!panelFocus"
  },

  {
    // Go to next panel (terminal, output, debug console, problems, etc.).
    "key": "alt+k",
    "command": "workbench.action.nextPanelView",
    "when": "panelFocus"
  },
  {
    // Go to previous panel (terminal, output, debug console, problems, etc.).
    "key": "alt+j",
    "command": "workbench.action.previousPanelView",
    "when": "panelFocus"
  },

  {
    "key": "alt+shift+k",
    "command": "workbench.action.moveEditorRightInGroup",
    "when": "editorTextFocus"
  },

  {
    "key": "alt+shift+j",
    "command": "workbench.action.moveEditorLeftInGroup",
    "when": "editorTextFocus"
  },

  {
    "key": "alt+c",
    "command": "workbench.files.action.collapseExplorerFolders",
    "when": "sideBarFocus && activeViewlet == 'workbench.view.explorer'"
  },

  {
    "key": "alt+shift+b",
    "command": "workbench.action.toggleAuxiliaryBar"
  },

  {
    "key": "alt+z",
    "command": "workbench.action.toggleZenMode"
  },

  {
    "key": "shift+alt+d",
    "command": "workbench.action.toggleLightDarkThemes"
  },

  {
    // Open the Settings UI and the Settings JSON file.
    "key": "ctrl+alt+shift+s",
    "command": "runCommands",
    "args": {
      "commands": [
        // "workbench.action.newGroupRight",
        "workbench.action.openApplicationSettingsJson",
        "workbench.action.openGlobalSettings",
        // "workbench.action.moveEditorGroupToNewWindow",
        "workbench.action.openApplicationSettingsJson"
      ]
    }
  },

  {
    // Open the Keybindings UI and the Keybindings JSON file.
    "key": "ctrl+alt+shift+k",
    "command": "runCommands",
    "args": {
      "commands": [
        // "workbench.action.newGroupRight",
        "workbench.action.openGlobalKeybindingsFile",
        "workbench.action.openGlobalKeybindings",
        // "workbench.action.moveEditorGroupToNewWindow",
        "workbench.action.openGlobalKeybindingsFile"
      ]
    }
  },

  {
    // Search through all symbols in a file. Amazing feature for productivity!
    "key": "ctrl+r",
    "command": "workbench.action.gotoSymbol"
  },

  {
    // Search through all symbols in the workspace.
    "key": "ctrl+t",
    "command": "workbench.action.showAllSymbols"
  },

  {
    // If the panel is active, but not maximized, maximize it.
    "key": "ctrl+alt+`",
    "command": "workbench.action.toggleMaximizedPanel",
    "when": "panelFocus && terminalFocus"
  },

  {
    // If the panel is not active, activate and maximize it.
    "key": "ctrl+alt+`",
    "command": "workbench.action.toggleMaximizedPanel",
    "when": "!panelFocus || !terminalFocus"
  },

  {
    // Toggle focus between panel and editor.
    "key": "alt+t",
    "command": "workbench.action.focusLastEditorGroup",
    "when": "panelFocus"
  },
  {
    // Toggle focus between panel and editor.
    "key": "alt+t",
    "command": "workbench.action.focusPanel",
    "when": "!panelFocus"
  },

  {
    // Ctrl+p is very useful in the terminal, so we override the default and
    // send the key sequence to the terminal.
    "key": "ctrl+p",
    "command": "workbench.action.terminal.sendSequence",
    "args": {
      "text": "\u0010"
    },
    "when": "terminalFocus"
  },

  {
    // Annoying default keybinding.
    "key": "ctrl+j",
    "command": "-workbench.action.togglePanel"
  },

  {
    "key": "alt+p",
    "command": "workbench.action.pinEditor",
    "when": "!activeEditorIsPinned"
  },
  {
    "key": "alt+p",
    "command": "workbench.action.unpinEditor",
    "when": "activeEditorIsPinned"
  },

  {
    // Move the panel to a new position.
    "key": "ctrl+; ctrl+l",
    "command": "workbench.action.positionPanelRight",
    "when": "terminalFocus && panelFocus && panelPosition == 'bottom'"
  },

  {
    // Move the panel to a new position.
    "key": "ctrl+; ctrl+j",
    "command": "workbench.action.positionPanelBottom",
    "when": "terminalFocus && panelFocus && panelPosition == 'right'"
  },

  {
    // Resize panel.
    "key": "ctrl+; ctrl+k",
    "command": "workbench.action.terminal.resizePaneUp",
    "when": "terminalFocus && panelFocus"
  },

  {
    // Resize panel.
    "key": "ctrl+; ctrl+j",
    "command": "workbench.action.terminal.resizePaneDown",
    "when": "terminalFocus && panelFocus && panelPosition == 'bottom'"
  },

  {
    // Resize panel.
    "key": "ctrl+; ctrl+h",
    "command": "workbench.action.terminal.resizePaneLeft",
    "when": "terminalFocus && panelFocus"
  },

  {
    // Resize panel.
    "key": "ctrl+; ctrl+l",
    "command": "workbench.action.terminal.resizePaneRight",
    "when": "terminalFocus && panelFocus && panelPosition == 'right'"
  },

  {
    "key": "ctrl+enter",
    "command": "-github.copilot.generate"
  },

  {
    "key": "alt+shift+enter",
    "command": "github.copilot.generate"
  },

  {
    // Unnecessary default keybinding (ctrl+p is better).
    "key": "ctrl+e",
    "command": "-workbench.action.quickOpen"
  },

  {
    // Insert the next suggested word instead of the full suggestion.
    "key": "ctrl+l",
    "command": "editor.action.inlineSuggest.acceptNextWord",
    "when": "editorTextFocus && inlineSuggestionVisible"
  },

  {
    "key": "ctrl+k ctrl+c",
    "command": "github.copilot.completions.toggle",
    "when": "editorTextFocus"
  },

  {
    // <C-n/p> to move to the next/previous find match.
    "key": "ctrl+n",
    "command": "editor.action.moveSelectionToNextFindMatch",
    // "when": "neovim.init && (editorTextFocus && editorHasSelection && neovim.mode == 'insert')"
    "when": "editorTextFocus && editorHasSelection && (!neovim.init || (neovim.init && neovim.mode == 'insert'))"
  },

  {
    // <C-n/p> to move to the next/previous find match.
    "key": "ctrl+p",
    "command": "editor.action.moveSelectionToPreviousFindMatch",
    "when": "editorTextFocus && editorHasSelection && (!neovim.init || (neovim.init && neovim.mode == 'insert'))"
  },

  // #region Cursor movements by line, word and camelcase humps. {{{
  {
    "key": "CURSOR MOVEMENTS BY LINE, WORD AND CAMELCASE HUMPS - START"
  },

  // TODO: I don't think this makes sense. Consider removing. {{{
  //
  //    {
  //      // Move cursor one word left.
  //      "key": "ctrl+h",
  //      "command": "cursorWordLeft"
  //    },
  //    {
  //      // Select one word left.
  //      "key": "ctrl+shift+h",
  //      "command": "cursorWordLeftSelect"
  //    },
  //    {
  //      // Move cursor one camelcase hump left.
  //      "key": "alt+h",
  //      "command": "cursorWordPartLeft"
  //    },
  //    {
  //      // Select one camelcase hump left.
  //      "key": "alt+shift+h",
  //      "command": "cursorWordPartLeftSelect"
  //    },
  //    {
  //      // Move cursor one word right.
  //      "key": "ctrl+l",
  //      "command": "cursorWordRight",
  //      "when": "!(editorTextFocus && inlineSuggestionVisible)"
  //    },
  //    {
  //      // Select one word right.
  //      "key": "ctrl+shift+l",
  //      "command": "cursorWordRightSelect"
  //    },
  //    {
  //      // Move cursor one camelcase hump right.
  //      "key": "alt+l",
  //      "command": "cursorWordPartRight"
  //    },
  //    {
  //      // Select one camelcase hump right.
  //      "key": "alt+shift+l",
  //      "command": "cursorWordPartRightSelect"
  //    },
  //    TODO: This doesn't make sense.
  //    {
  //      "key": "ctrl+; ctrl+d",
  //      "command": "cursorPageDown"
  //    },
  //    {
  //      "key": "ctrl+; ctrl+u",
  //      "command": "cursorPageUp"
  //    },
  //
  // }}}

  {
    // Move cursor one camelcase hump left.
    "key": "alt+left",
    "command": "cursorWordPartLeft",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    // Select one camelcase hump left.
    "key": "alt+shift+left",
    "command": "cursorWordPartLeftSelect",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    // Move cursor one camelcase hump right.
    "key": "alt+right",
    "command": "cursorWordPartRight"
  },
  {
    // Select one camelcase hump right.
    "key": "alt+shift+right",
    "command": "cursorWordPartRightSelect"
  },

  {
    "key": "CURSOR MOVEMENTS BY LINE, WORD AND CAMELCASE HUMPS - END"
  },
  // #endregion Improved cursor movements by line, word and camelcase humps. }}}

  {
    "key": "ctrl+o",
    "command": "workbench.action.navigateBack"
  },

  {
    "key": "ctrl+i",
    "command": "workbench.action.navigateForward"
  },

  {
    // Move the cursor to the bottom of the editor and create a new heading 2.
    // I use this in my tasks markdown file to quickly add new tasks, always at
    // the bottom of the file.
    "key": "ctrl+enter",
    "command": "runCommands",
    "args": {
      "commands": [
        {
          "command": "cursorBottom"
        },
        {
          "command": "editor.action.insertLineAfter"
        },
        {
          "command": "editor.action.insertSnippet",
          "args": {
            "snippet": "## ${CURRENT_HOUR}h${CURRENT_MINUTE} - ${1/(.*)/${1:/capitalize}/}\n\n"
          }
        }
      ]
    },
    "when": "editorTextFocus && !editorReadonly && !notebookEditorFocused && editorLangId == 'markdown'"
  },

  {
    // Add a new task to the bottom of the tasks.md file, assuming it is the
    // first editor in the group.
    // Steps:
    //  - Go to the file in index 1 (should be the tasks.md file)
    //  - Move the cursor to the bottom
    //  - Create a new heading 2
    "key": "ctrl+shift+enter",
    "command": "runCommands",
    "args": {
      "commands": [
        {
          "command": "workbench.action.firstEditorInGroup"
        },
        {
          "command": "cursorBottom"
        },
        {
          "command": "editor.action.insertLineAfter"
        },
        {
          "command": "editor.action.insertSnippet",
          "args": {
            "snippet": "## $0"
          }
        }
      ]
    },
    "when": "editorTextFocus && !editorReadonly"
  },

  {
    "key": "alt+enter",
    "command": "workbench.action.tasks.runTask",
    "args": "Mind Conductor: Quick Entry",
    // I use ctrl+enter to commit, in the git panel, so I don't want this
    // command to run when the git panel is visible and focused. But if it is
    // visible but not focused, I want it to run.
    "when": "!view.workbench.scm.visible || editorTextFocus"
  },

  {
    "key": "ctrl+j",
    "command": "workbench.action.tasks.runTask",
    "args": "Mind Conductor: Daily Journal",
    "when": "!terminalFocus"
  },

  {
    "key": "ctrl+tab",
    "command": "workbench.action.nextEditor"
  },
  {
    "key": "ctrl+shift+tab",
    "command": "workbench.action.previousEditor"
  },

  {
    "key": "ctrl+shift+c",
    "command": "runCommands",
    "args": {
      "commands": [
        {
          "command": "editor.action.insertSnippet",
          "args": {
            "snippet": "```$0\n```"
          }
        }
      ]
    },
    "when": "!terminalFocus"
  },

  {
    "key": "NEXT KEYBINDING/KEYMAP/MAPPING - ADD MANUALLY 👆🏽"
  },

  {
    "key": "NEXT KEYBINDING/KEYMAP/MAPPING - ADD WITH KEYBINDINGS UI 👇🏽"
  },

  {
    "key": "ctrl+shift+d",
    "command": "editor.action.selectHighlights",
    "when": "editorFocus"
  },
  {
    "key": "ctrl+shift+/",
    "command": "editor.action.blockComment",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+shift+s",
    "command": "workbench.action.files.saveFiles"
  },
  {
    "key": "ctrl+shift+s",
    "command": "-workbench.action.files.saveAs"
  },
  {
    "key": "ctrl+enter",
    "command": "python.execInREPL",
    "when": "config.python.REPL.sendToNativeREPL && editorTextFocus && !isCompositeNotebook && !jupyter.ownsSelection && !notebookEditorFocused && editorLangId == 'python'"
  },
  {
    "key": "ctrl+enter",
    "command": "python.execSelectionInTerminal",
    "when": "editorTextFocus && !findInputFocussed && !isCompositeNotebook && !jupyter.ownsSelection && !notebookEditorFocused && !replaceInputFocussed && editorLangId == 'python'"
  },

  {
    // Sometimes I press it by mistake and it simply closes all of VSCode.
    "key": "ctrl+q",
    "command": "-workbench.action.quit"
  },
  {
    // Sometimes I press it by mistake and it simply closes all of VSCode.
    "key": "ctrl+shift+q",
    "command": "-workbench.action.quit"
  },
  {
    "key": "ctrl+alt+h",
    "command": "editor.action.startFindReplaceAction",
    "when": "editorFocus || editorIsOpen"
  },
  {
    "key": "ctrl+h",
    "command": "-editor.action.startFindReplaceAction",
    "when": "editorFocus || editorIsOpen"
  },
  // #region Use `alt+l` to open the previous recently used editor.
  // // Disabled because I normally use ctrl+tab for this.
  // {
  //   "key": "alt+l",
  //   "command": "workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup",
  //   "when": "!activeEditorGroupEmpty"
  // },
  // {
  //   "key": "alt+l",
  //   "command": "workbench.action.quickOpenNavigateNextInEditorPicker",
  //   "when": "inEditorsPicker && inQuickOpen"
  // },
  // {
  //   "key": "shift+alt+l",
  //   "command": "workbench.action.quickOpenLeastRecentlyUsedEditorInGroup",
  //   "when": "!activeEditorGroupEmpty"
  // },
  // {
  //   "key": "shift+alt+l",
  //   "command": "workbench.action.quickOpenNavigatePreviousInEditorPicker",
  //   "when": "inEditorsPicker && inQuickOpen"
  // },
  // #endregion

  // #region Change default inline Copilot Chat from `ctrl+i` to `ctrl+; ctrl+i`. {{{
  {
    "key": "ctrl+; ctrl+i",
    "command": "-testing.toggleInlineTestOutput"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "inlineChat2.close",
    "when": "inlineChatHasEditsAgent && inlineChatVisible && !chatEdits.isRequestInProgress && chatEdits.requestCount == '0' || inlineChatHasEditsAgent && inlineChatVisible && !chatEdits.hasEditorModifications && !chatEdits.isRequestInProgress && chatEdits.requestCount == '0'"
  },
  {
    "key": "ctrl+i",
    "command": "-inlineChat2.close",
    "when": "inlineChatHasEditsAgent && inlineChatVisible && !chatEdits.isRequestInProgress && chatEdits.requestCount == '0' || inlineChatHasEditsAgent && inlineChatVisible && !chatEdits.hasEditorModifications && !chatEdits.isRequestInProgress && chatEdits.requestCount == '0'"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "inlineChat.start",
    "when": "editorFocus && inlineChatHasEditsAgent && inlineChatPossible && !editorReadonly && !editorSimpleInput || editorFocus && inlineChatHasProvider && inlineChatPossible && !editorReadonly && !editorSimpleInput"
  },
  {
    "key": "ctrl+i",
    "command": "-inlineChat.start",
    "when": "editorFocus && inlineChatHasEditsAgent && inlineChatPossible && !editorReadonly && !editorSimpleInput || editorFocus && inlineChatHasProvider && inlineChatPossible && !editorReadonly && !editorSimpleInput"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "workbench.action.terminal.chat.start",
    "when": "chatIsEnabled && terminalChatAgentRegistered && terminalFocusInAny && terminalHasBeenCreated || chatIsEnabled && terminalChatAgentRegistered && terminalFocusInAny && terminalProcessSupported"
  },
  {
    "key": "ctrl+i",
    "command": "-workbench.action.terminal.chat.start",
    "when": "chatIsEnabled && terminalChatAgentRegistered && terminalFocusInAny && terminalHasBeenCreated || chatIsEnabled && terminalChatAgentRegistered && terminalFocusInAny && terminalProcessSupported"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "inlineChat2.reveal",
    "when": "inlineChatHasEditsAgent && !chatEdits.isGlobalEditingSession && chatEdits.requestCount >= 1"
  },
  {
    "key": "ctrl+i",
    "command": "-inlineChat2.reveal",
    "when": "inlineChatHasEditsAgent && !chatEdits.isGlobalEditingSession && chatEdits.requestCount >= 1"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "inlineChat.startWithCurrentLine",
    "when": "inlineChatHasProvider && inlineChatShowingHint && !editorReadonly && !inlineChatVisible"
  },
  {
    "key": "ctrl+i",
    "command": "-inlineChat.startWithCurrentLine",
    "when": "inlineChatHasProvider && inlineChatShowingHint && !editorReadonly && !inlineChatVisible"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "search.action.searchWithAI",
    "when": "hasAIResultProviderKey && searchViewletFocus"
  },
  {
    "key": "ctrl+i",
    "command": "-search.action.searchWithAI",
    "when": "hasAIResultProviderKey && searchViewletFocus"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "focusSuggestion",
    "when": "suggestWidgetVisible && textInputFocus && !suggestWidgetHasFocusedSuggestion"
  },
  {
    "key": "ctrl+i",
    "command": "-focusSuggestion",
    "when": "suggestWidgetVisible && textInputFocus && !suggestWidgetHasFocusedSuggestion"
  },
  {
    "key": "ctrl+i",
    "command": "-inlineChat.holdForSpeech",
    "when": "hasSpeechProvider && inlineChatVisible && textInputFocus"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "notebook.cell.chat.start",
    "when": "config.notebook.experimental.cellChat && notebookChatAgentRegistered && notebookEditable && notebookEditorFocused && !inputFocus || config.notebook.experimental.generate && notebookChatAgentRegistered && notebookEditable && notebookEditorFocused && !inputFocus"
  },
  {
    "key": "ctrl+i",
    "command": "-notebook.cell.chat.start",
    "when": "config.notebook.experimental.cellChat && notebookChatAgentRegistered && notebookEditable && notebookEditorFocused && !inputFocus || config.notebook.experimental.generate && notebookChatAgentRegistered && notebookEditable && notebookEditorFocused && !inputFocus"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "toggleSuggestionDetails",
    "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus"
  },
  {
    "key": "ctrl+i",
    "command": "-toggleSuggestionDetails",
    "when": "suggestWidgetHasFocusedSuggestion && suggestWidgetVisible && textInputFocus"
  },
  {
    "key": "ctrl+i",
    "command": "-workbench.action.chat.holdToVoiceChatInChatView"
  },
  {
    "key": "ctrl+; ctrl+i",
    "command": "workbench.action.terminal.suggestToggleDetails",
    "when": "simpleSuggestWidgetHasFocusedSuggestion && terminalFocus && terminalHasBeenCreated && terminalIsOpen && terminalSuggestWidgetVisible || simpleSuggestWidgetHasFocusedSuggestion && terminalFocus && terminalIsOpen && terminalProcessSupported && terminalSuggestWidgetVisible"
  },
  {
    "key": "ctrl+i",
    "command": "-workbench.action.terminal.suggestToggleDetails",
    "when": "simpleSuggestWidgetHasFocusedSuggestion && terminalFocus && terminalHasBeenCreated && terminalIsOpen && terminalSuggestWidgetVisible || simpleSuggestWidgetHasFocusedSuggestion && terminalFocus && terminalIsOpen && terminalProcessSupported && terminalSuggestWidgetVisible"
  },

  // #endregion Change default inline Copilot Chat from `ctrl+i` to `ctrl+; ctrl+i`. }}}

  {
    "key": "ctrl+q",
    "command": "-workbench.action.quickOpenView"
  },
  {
    "key": "ctrl+q",
    "command": "-workbench.action.quickOpenNavigateNextInViewPicker",
    "when": "inQuickOpen && inViewsPicker"
  },
  {
    "key": "ctrl+backspace",
    "command": "-chatEditing.discardAllFiles",
    "when": "hasUndecidedChatEditingResource && inChatInput && !chatInputHasText && !chatSessionRequestInProgress"
  },
  {
    "key": "ctrl+backspace",
    "command": "-inlineChat2.undo",
    "when": "inlineChatHasEditsAgent && inlineChatVisible && !chatEdits.isRequestInProgress"
  },

  {
    "key": "ctrl+shift+f",
    "command": "workbench.action.terminal.focusFind",
    "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported"
  },
  {
    "key": "ctrl+f",
    "command": "-workbench.action.terminal.focusFind",
    "when": "terminalFindFocused && terminalHasBeenCreated || terminalFindFocused && terminalProcessSupported || terminalFocusInAny && terminalHasBeenCreated || terminalFocusInAny && terminalProcessSupported"
  },
  {
    "key": "alt+a",
    "command": "workbench.action.chat.openAgent",
    "when": "config.chat.agent.enabled && !chatSetupDisabled && !chatSetupHidden"
  },
  {
    "key": "alt+a",
    "command": "workbench.panel.chat",
    "when": "workbench.panel.chat.view.copilot.active"
  },
  {
    "key": "THE END! 👆🏽"
  },
  {
    "key": "ctrl+g h",
    "command": "editor.action.showHover",
    "when": "editorTextFocus"
  },
  // {
  //   "key": "alt+`",
  //   "command": "workbench.action.chat.voiceChatInChatView"
  // },
  // {
  //   "key": "ctrl+u",
  //   "command": "workbench.action.chat.startVoiceChat",
  //   "when": "!voiceChatInProgress"
  // },
  // {
  //   "key": "ctrl+u",
  //   "command": "workbench.action.chat.stopListeningAndSubmit",
  //   "when": "voiceChatInProgress"
  // },
  // {
  //   "key": "alt+`",
  //   "command": "workbench.action.editorDictation.start",
  //   "when": "editorTextFocus && !editorDictation.inProgress"
  // },
  // {
  //   "key": "alt+`",
  //   "command": "workbench.action.editorDictation.stop",
  //   "when": "editorTextFocus && editorDictation.inProgress"
  // },
  // {
  //   "key": "alt+`",
  //   "command": "-workbench.action.editorDictation.start",
  //   "when": "hasSpeechProvider && !editorReadonly && !speechToTextInProgress"
  // },
  {
    "key": "ctrl+alt+w",
    "command": "workbench.action.closeOtherEditors"
  },
  {
    "key": "ctrl+g p",
    "command": "editor.action.peekDefinition",
    "when": "editorHasDefinitionProvider && editorTextFocus && !inReferenceSearchEditor && !isInEmbeddedEditor"
  },
  {
    "key": "ctrl+g l",
    "command": "workbench.action.gotoLine",
    "when": "editorTextFocus"
  },
  {
    "key": "ctrl+g",
    "command": "-workbench.action.gotoLine"
  },
  {
    "key": "alt+left",
    "command": "-workbench.action.navigateBack",
    "when": "canNavigateBack"
  },
  {
    "key": "alt+d",
    "command": "workbench.action.search.toggleQueryDetails",
    "when": "inSearchEditor || searchViewletFocus"
  },
  {
    "key": "ctrl+g",
    "command": "-workbench.action.terminal.goToRecentDirectory",
    "when": "terminalFocus && terminalHasBeenCreated || terminalFocus && terminalProcessSupported"
  },
  {
    "key": "alt+d",
    "command": "editor.action.duplicateSelection",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+up",
    "command": "editor.action.smartSelect.expand",
    "when": "editorTextFocus"
  },
  {
    "key": "shift+alt+right",
    "command": "-editor.action.smartSelect.expand",
    "when": "editorTextFocus"
  },
  {
    "key": "shift+alt+down",
    "command": "editor.action.smartSelect.shrink",
    "when": "editorTextFocus"
  },
  {
    "key": "shift+alt+left",
    "command": "-editor.action.smartSelect.shrink",
    "when": "editorTextFocus"
  },
  {
    "key": "shift+alt+up",
    "command": "-editor.action.copyLinesUpAction",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "shift+alt+up",
    "command": "-notebook.cell.copyUp",
    "when": "notebookEditorFocused && !inputFocus"
  },
  {
    "key": "shift+alt+down",
    "command": "-notebook.cell.copyDown",
    "when": "notebookEditorFocused && !inputFocus"
  },
  {
    "key": "shift+alt+down",
    "command": "-editor.action.copyLinesDownAction",
    "when": "editorTextFocus && !editorReadonly"
  },
  // {
  //   "key": "ctrl+j",
  //   "command": "editor.action.insertLineAfter",
  //   "when": "editorTextFocus && !editorReadonly"
  // },
  {
    "key": "ctrl+m",
    "command": "editor.action.insertLineAfter",
    "when": "editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+m",
    "command": "-editor.action.toggleTabFocusMode"
  },
  {
    "key": "shift+alt+w",
    "command": "editor.action.toggleWordWrap"
  },
  {
    "key": "ctrl+; ctrl+d",
    "command": "editor.action.revealDefinition",
    "when": "editorHasDefinitionProvider && editorTextFocus"
  },
  {
    "key": "alt+9",
    "command": "workbench.action.lastEditorInGroup"
  },
  {
    "key": "alt+0",
    "command": "-workbench.action.lastEditorInGroup"
  },
  {
    "key": "alt+0",
    "command": "workbench.action.firstEditorInGroup"
  },
  {
    "key": "alt+q",
    "command": "workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup",
    "when": "!activeEditorGroupEmpty"
  },
  {
    "key": "alt+l",
    "command": "workbench.action.quickOpenPreviousRecentlyUsedEditorInGroup",
    "when": "!activeEditorGroupEmpty"
  },
  {
    "key": "alt+q",
    "command": "workbench.action.quickOpenNavigateNextInEditorPicker",
    "when": "inEditorsPicker && inQuickOpen"
  },
  {
    "key": "alt+l",
    "command": "workbench.action.quickOpenNavigateNextInEditorPicker",
    "when": "inEditorsPicker && inQuickOpen"
  },
  {
    "key": "ctrl+k ctrl+p",
    "command": "copyRelativeFilePath"
  },
  {
    "key": "ctrl+k ctrl+v",
    "command": "workbench.action.chat.quickVoiceChat"
  },
  // {
  //   // TODO: Figure out a safer way of doing this. I just evaluated the string
  //   // `functions -` unintentionally.
  //   "key": "ctrl+enter",
  //   "command": "workbench.action.terminal.runSelectedText",
  //   "when": "terminalProcessSupported && editorLangId != 'markdown'"
  // },
  {
    "key": "ctrl+k ctrl+d",
    "command": "editor.action.revealDefinition",
    "when": "editorHasDefinitionProvider && editorTextFocus"
  },
  {
    "key": "ctrl+k ctrl+o",
    "command": "workbench.action.terminal.copyLastCommandOutput"
  },
  {
    "key": "ctrl+k ctrl+f",
    "command": "workbench.action.terminal.copyLastCommandAndLastCommandOutput"
  },
  {
    "key": "ctrl+k ctrl+o",
    "command": "-workbench.action.files.openLocalFolder",
    "when": "remoteFileDialogVisible"
  },
  {
    "key": "ctrl+k ctrl+o",
    "command": "-workbench.action.files.openFolder",
    "when": "openFolderWorkspaceSupport"
  },
  {
    "key": "ctrl+k ctrl+f",
    "command": "-editor.action.formatSelection",
    "when": "editorHasDocumentSelectionFormattingProvider && editorTextFocus && !editorReadonly"
  },
  {
    "key": "ctrl+shift+c",
    "command": "-workbench.action.terminal.openNativeConsole",
    "when": "!terminalFocus"
  }
]
